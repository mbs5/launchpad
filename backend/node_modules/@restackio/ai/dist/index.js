"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@temporalio/client");
const worker_1 = require("@temporalio/worker");
const observability_1 = require("./observability");
class Restack {
    constructor(options) {
        this.client = null;
        this.options = options;
    }
    getConnectionOptions() {
        var _a, _b, _c, _d, _e;
        const address = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : "localhost:7233";
        const engineId = (_d = (_c = this.options) === null || _c === void 0 ? void 0 : _c.engineId) !== null && _d !== void 0 ? _d : "local";
        let options = {
            address,
            metadata: {
                "restack-engineId": engineId,
            },
        };
        if ((_e = this.options) === null || _e === void 0 ? void 0 : _e.apiKey) {
            options = {
                address,
                tls: address.includes("localhost") ? false : true,
                apiKey: this.options.apiKey,
                metadata: {
                    "restack-engineId": engineId,
                },
            };
        }
        return options;
    }
    createClient(connectionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const connectOptions = connectionOptions !== null && connectionOptions !== void 0 ? connectionOptions : this.getConnectionOptions();
            const connection = yield client_1.Connection.connect(connectOptions);
            return new client_1.Client({
                connection,
                namespace: (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.temporalNamespace) !== null && _b !== void 0 ? _b : "default",
            });
        });
    }
    connect(connectionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.client) {
                observability_1.logger.info("Reusing existing client connection.");
                return;
            }
            try {
                this.client = yield this.createClient(connectionOptions);
                observability_1.logger.info("Connected to Restack Engine.");
            }
            catch (e) {
                observability_1.logger.error(`Failed to connect to Restack Engine: ${e}`);
                throw e;
            }
        });
    }
    createService(_a) {
        return __awaiter(this, arguments, void 0, function* ({ taskQueue = "restack", workflowsPath, functions, options = {
            rateLimit: 100000,
            maxConcurrentWorkflowRuns: 3000,
            maxConcurrentFunctionRuns: 1000,
        }, }) {
            var _b, _c;
            try {
                observability_1.logger.info("Starting service...");
                const connectionOptions = this.getConnectionOptions();
                const connection = yield worker_1.NativeConnection.connect(connectionOptions);
                const engineId = connectionOptions.metadata["restack-engineId"].toString();
                const service = yield worker_1.Worker.create({
                    identity: `${engineId}-${process.pid}-${taskQueue}`,
                    connection,
                    namespace: (_c = (_b = this.options) === null || _b === void 0 ? void 0 : _b.temporalNamespace) !== null && _c !== void 0 ? _c : "default",
                    taskQueue,
                    workflowsPath,
                    activities: functions,
                    maxActivitiesPerSecond: options.rateLimit,
                    maxConcurrentWorkflowTaskExecutions: options.maxConcurrentWorkflowRuns,
                    maxConcurrentActivityTaskExecutions: options.maxConcurrentFunctionRuns,
                });
                observability_1.logger.info("Service created successfully.");
                return service;
            }
            catch (e) {
                observability_1.logger.error(`Failed to start service: ${e}`, { error: e });
                throw e;
            }
        });
    }
    runService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (service.options.taskQueue === "restack") {
                    // start a parallel service for playground
                    observability_1.logger.info("Creating playground service...");
                    const playgroundWorkflowsPath = require.resolve("./playground/workflow");
                    const playgroundService = yield worker_1.Worker.create({
                        identity: `${process.pid}-playground`,
                        connection: service.options.connection,
                        namespace: service.options.namespace,
                        taskQueue: "playground",
                        workflowsPath: playgroundWorkflowsPath,
                    });
                    observability_1.logger.info("Services ready to receive workflows and events");
                    yield Promise.all([service.run(), playgroundService.run()]);
                }
                else {
                    observability_1.logger.info("Service ready to receive workflows and events");
                    yield service.run();
                }
            }
            catch (e) {
                observability_1.logger.error(`Failed to run service: ${e}`, { error: e });
                throw e;
            }
        });
    }
    /**
     * Starts a service with the specified configuration.
     *
     * @param {Object} params - The parameters for starting the service.
     * @param {string} [params.taskQueue='restack'] - The task queue name for the service.
     * @param {string} [params.workflowsPath] - The path to the workflows directory.
     * @param {WorkerOptions['activities']} [params.functions] - The functions to be registered with the service.
     * @param {Object} [params.options] - Additional options for the service.
     * @param {number} [params.options.rateLimit] - The rate limit for functions.
     * @param {number} [params.options.maxConcurrentWorkflowRuns] - The maximum number of concurrent workflow runs.
     * @param {number} [params.options.maxConcurrentFunctionRuns] - The maximum number of concurrent function runs.
     * @returns {Promise<void>} A promise that resolves when the service has started.
     * @throws {Error} If the service fails to start.
     */
    startService(_a) {
        return __awaiter(this, arguments, void 0, function* ({ taskQueue = "restack", workflowsPath, functions, options, }) {
            const service = yield this.createService({
                taskQueue,
                workflowsPath,
                functions,
                options,
            });
            yield this.runService(service);
        });
    }
    /**
     * Schedules or starts a workflow.
     *
     * @param {Object} params - The parameters for scheduling or starting the workflow.
     * @param {string} params.workflowName - The name of the workflow to schedule or start.
     * @param {string} params.workflowId - The ID of the workflow.
     * @param {Object} [params.input] - The input data for the workflow.
     * @param {string} [params.taskQueue='restack'] - The task queue for the workflow.
     * @param {ScheduleSpec} [params.schedule] - The schedule specification for the workflow. If not provided, the workflow starts immediately.
     * @returns {Promise<string>} A promise that resolves to the runId (for immediate start) or scheduleId (for scheduled workflows).
     * @throws {Error} If the workflow fails to start or schedule.
     */
    scheduleWorkflow(_a) {
        return __awaiter(this, arguments, void 0, function* ({ workflowName, workflowId, input, taskQueue = "restack", schedule, }) {
            yield this.connect();
            if (this.client) {
                try {
                    const connectionOptions = this.getConnectionOptions();
                    const engineId = connectionOptions.metadata["restack-engineId"].toString();
                    if (!schedule) {
                        // Start the workflow immediately
                        const handle = yield this.client.workflow.start(workflowName, Object.assign(Object.assign({ taskQueue, workflowId: `${engineId}-${workflowId}` }, (input && { args: [input] })), { memo: {
                                engineId,
                            }, searchAttributes: {
                                engineId: [engineId],
                            } }));
                        observability_1.logger.info(`Workflow started immediately with runId: ${handle.firstExecutionRunId}`);
                        return handle.firstExecutionRunId;
                    }
                    else {
                        // Schedule the workflow using ScheduleSpec
                        const scheduled = yield this.client.schedule.create({
                            scheduleId: `${engineId}-${workflowId}`,
                            spec: schedule,
                            action: Object.assign(Object.assign({ type: "startWorkflow", workflowType: workflowName, taskQueue }, (input && { args: [input] })), { searchAttributes: {
                                    engineId: [engineId],
                                } }),
                            memo: {
                                engineId,
                            },
                            searchAttributes: {
                                engineId: [engineId],
                            },
                        });
                        observability_1.logger.info(`Workflow scheduled with scheduleId: ${scheduled.scheduleId}`);
                        return scheduled.scheduleId;
                    }
                }
                catch (e) {
                    observability_1.logger.error(`Failed to start or schedule workflow: ${e}`);
                    throw e;
                }
            }
            else {
                throw new Error("Workflow not started or scheduled due to failed connection.");
            }
        });
    }
    /**
     * Retrieves a workflow handle.
     *
     * @param {Object} params - The parameters for retrieving the workflow handle.
     * @param {string} params.workflowId - The ID of the workflow.
     * @param {string} params.runId - The run ID of the workflow execution.
     * @returns {Promise<WorkflowHandle<Workflow>>} A promise that resolves to the workflow handle.
     * @throws {Error} If the workflow handle cannot be retrieved.
     */
    getWorkflowHandle(_a) {
        return __awaiter(this, arguments, void 0, function* ({ workflowId, runId, }) {
            yield this.connect();
            if (this.client) {
                try {
                    const connectionOptions = this.getConnectionOptions();
                    const engineId = connectionOptions.metadata["restack-engineId"].toString();
                    const handle = this.client.workflow.getHandle(`${engineId}-${workflowId}`, runId);
                    return handle;
                }
                catch (e) {
                    observability_1.logger.error(`Failed to get workflow result: ${e}`);
                    throw e;
                }
            }
            else {
                throw new Error("Workflow result not retrieved due to failed connection.");
            }
        });
    }
    /**
     * Retrieves the result of a workflow execution.
     *
     * @param {Object} params - The parameters for retrieving the workflow result.
     * @param {string} params.workflowId - The ID of the workflow.
     * @param {string} params.runId - The run ID of the workflow execution.
     * @returns {Promise<WorkflowResultType<Workflow>>} A promise that resolves to the workflow result.
     * @throws {Error} If the workflow result cannot be retrieved.
     */
    getWorkflowResult(_a) {
        return __awaiter(this, arguments, void 0, function* ({ workflowId, runId, }) {
            yield this.connect();
            if (this.client) {
                try {
                    const connectionOptions = this.getConnectionOptions();
                    const engineId = connectionOptions.metadata["restack-engineId"].toString();
                    const handle = this.client.workflow.getHandle(`${engineId}-${workflowId}`, runId);
                    return yield handle.result();
                }
                catch (e) {
                    observability_1.logger.error(`Failed to get workflow result: ${e}`);
                    throw e;
                }
            }
            else {
                throw new Error("Workflow result not retrieved due to failed connection.");
            }
        });
    }
    /**
     * Sends an event to a running workflow.
     * Cannot be called from a workflow, only from a client or a function.
     *
     * @param {SendWorkflowEvent} params - The parameters for sending the workflow event.
     * @param {Object} params.event - The event to send.
     * @param {string} params.event.name - The name of the event.
     * @param {any} params.event.input - The input data for the event.
     * @param {Object} params.workflow - The workflow information.
     * @param {string} params.workflow.workflowId - The ID of the workflow.
     * @param {string} params.workflow.runId - The run ID of the workflow execution.
     * @returns {Promise<unknown>} A promise that resolves to the result of the event execution.
     * @throws {Error} If the event fails to send.
     */
    sendWorkflowEvent(_a) {
        return __awaiter(this, arguments, void 0, function* ({ event, workflow, }) {
            yield this.connect();
            if (this.client) {
                try {
                    const connectionOptions = this.getConnectionOptions();
                    const engineId = connectionOptions.metadata["restack-engineId"].toString();
                    const { workflowId, runId } = workflow;
                    const { name, input } = event;
                    const prefixedWorkflowId = workflowId.startsWith(`${engineId}-`)
                        ? workflowId
                        : `${engineId}-${workflowId}`;
                    const handle = this.client.workflow.getHandle(prefixedWorkflowId, runId);
                    return yield handle.executeUpdate(name, {
                        args: [input],
                    });
                }
                catch (e) {
                    observability_1.logger.error(`Failed to send workflow event: ${e}`);
                    throw e;
                }
            }
            else {
                throw new Error("Workflow result not retrieved due to failed connection.");
            }
        });
    }
    /**
     * Retrieves the latest data of a workflow event.
     *
     * @param {Object} params - The parameters for retrieving the workflow event.
     * @param {string} params.workflowId - The ID of the workflow.
     * @param {string} params.runId - The run ID of the workflow execution.
     * @param {string} params.eventName - The name of the event.
     * @returns {Promise<WorkflowResultType<Workflow>>} A promise that resolves to the workflow event data.
     * @throws {Error} If the workflow event cannot be retrieved.
     */
    getWorkflowEvent(_a) {
        return __awaiter(this, arguments, void 0, function* ({ workflowId, runId, eventName, }) {
            yield this.connect();
            if (this.client) {
                try {
                    const connectionOptions = this.getConnectionOptions();
                    const engineId = connectionOptions.metadata["restack-engineId"].toString();
                    const prefixedWorkflowId = workflowId.startsWith(`${engineId}-`)
                        ? workflowId
                        : `${engineId}-${workflowId}`;
                    const handle = this.client.workflow.getHandle(prefixedWorkflowId, runId);
                    return yield handle.query(eventName);
                }
                catch (e) {
                    observability_1.logger.error(`Failed to get workflow result: ${e}`);
                    throw e;
                }
            }
            else {
                throw new Error("Workflow result not retrieved due to failed connection.");
            }
        });
    }
    /**
     * Retrieves the latest data of a workflow memory.
     *
     * @param {Object} params - The parameters for retrieving the workflow memory.
     * @param {string} params.workflowId - The ID of the workflow.
     * @param {string} params.runId - The run ID of the workflow execution.
     * @param {string} params.memoryName - The name of the memory.
     * @returns {Promise<WorkflowResultType<Workflow>>} A promise that resolves to the workflow memory data.
     * @throws {Error} If the workflow memory cannot be retrieved.
     */
    getWorkflowMemory(_a) {
        return __awaiter(this, arguments, void 0, function* ({ workflowId, runId, memoryName, }) {
            yield this.connect();
            if (this.client) {
                try {
                    const connectionOptions = this.getConnectionOptions();
                    const engineId = connectionOptions.metadata["restack-engineId"].toString();
                    const prefixedWorkflowId = workflowId.startsWith(`${engineId}-`)
                        ? workflowId
                        : `${engineId}-${workflowId}`;
                    const handle = this.client.workflow.getHandle(prefixedWorkflowId, runId);
                    return yield handle.query(memoryName);
                }
                catch (e) {
                    observability_1.logger.error(`Failed to get workflow result: ${e}`);
                    throw e;
                }
            }
            else {
                throw new Error("Workflow result not retrieved due to failed connection.");
            }
        });
    }
}
exports.default = Restack;
