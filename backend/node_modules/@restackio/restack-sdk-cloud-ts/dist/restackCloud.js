var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import readline from 'readline';
import chalk from 'chalk';
import open from 'open';
import { loadingSpinner, prettyPrintStackModificationPlan } from './prompts.js';
import { validateUniqueStackName, validateUniqueApplicationName, prettyPrintDeployResults, getGitBranch, getRemoteUrl, ensureHttpPrefix, hasApplicationErrors, getApplicationWithGithubAppError, convertGitSshUrlToHttps, } from './utils.js';
import * as errorCodes from './errorCodes.js';
export class RestackCloud {
    /**
     * Creates an instance of the RestackCloud client.
     *
     * @param {string} token - The Restack SDK token.
     */
    constructor(token) {
        this.token = token;
        this.isPlan = process.env.RESTACK_CICD !== 'true';
        this.stacks = [];
        this.url = 'https://z5d8916c5-z0d84f6e6-gtw.z507f3bcc.blockdev.sh';
        this.stackPlanGenerated = false;
    }
    promptUser(question) {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });
        return new Promise((resolve) => {
            rl.question(question, (answer) => {
                rl.close();
                resolve(answer.toLowerCase() === 'y');
            });
        });
    }
    deployRestackPlan() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.url}/sdk/deploy`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'restack-token': this.token,
                },
                body: JSON.stringify({
                    stacks: this.stacks,
                }),
            });
            const data = yield response.json();
            return data;
        });
    }
    /**
     * Generates a stack plan and validates the stack and application names.
     *
     * @param {Object} params - The parameters for the stack.
     * @param {string} params.name - The name of the stack.
     * @param {boolean} [params.previewEnabled=false] - Flag to enable preview.
     * @param {Array} [params.applications=[]] - List of applications to include in the stack.
     *
     * @returns {Promise<string | null>} - The name of the created stack or null if the stack plan generation fails or the response is invalid.
     *
     * @throws {Error} - Throws an error if the stack plan generation fails or the response is invalid.
     */
    stack(_a) {
        return __awaiter(this, arguments, void 0, function* ({ name, previewEnabled = false, applications = [], }) {
            validateUniqueStackName(this.stacks, name);
            if (applications.length > 0) {
                validateUniqueApplicationName(applications);
            }
            let branch = '';
            let gitUrl = '';
            const allAppsHaveGitInfo = applications.every((app) => app.gitUrl && app.gitBranch);
            if (!allAppsHaveGitInfo) {
                try {
                    branch = yield getGitBranch();
                    gitUrl = yield getRemoteUrl();
                }
                catch (error) {
                    console.error(chalk.yellow('Failed to get git branch and remote url.\nPlease make sure you have git installed and you are running the Restack SDK from a directory that is agit repository.\nAlternatively, you can provide gitUrl and gitBranch for each application on your stack.'));
                    return null;
                }
            }
            console.log(chalk.green('Generating stack plan...'));
            const response = yield fetch(`${this.url}/sdk/plan`, {
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/json' }, (this.token && { 'restack-token': this.token })),
                body: JSON.stringify({
                    name,
                    previewEnabled,
                    applications: applications.map((app) => (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, app), { gitUrl: app.gitUrl ? convertGitSshUrlToHttps(app.gitUrl) : gitUrl, gitBranch: app.gitBranch || branch }), (app.dockerFilePath && {
                        dockerFilePath: app.dockerFilePath.replace(/^\.\//, ''),
                    })), (app.dockerBuildContext && {
                        dockerBuildContext: app.dockerBuildContext.replace(/^\.\//, ''),
                    })), (app.image && {
                        image: app.image,
                    })), (app.database && {
                        database: app.database,
                    })), { cloudStorage: !!app.cloudStorage, redis: !!app.redis }))),
                }),
            });
            if (response.status !== 200) {
                const errorMessage = (yield response.json());
                if (errorMessage.error === errorCodes.INVALID_RESTACK_SDK_TOKEN &&
                    errorMessage.createTokenUrl) {
                    const url = ensureHttpPrefix(errorMessage.createTokenUrl);
                    console.error(chalk.yellow(`Restack sdk token is invalid.\nPlease create one at ${chalk.green(url)}`));
                    yield open(url);
                }
                else {
                    console.error(chalk.yellow(`Failed to generate stack plan:\n${errorMessage.error}`));
                }
                return null;
            }
            console.log(chalk.green('Stack plan generated successfully'));
            const data = yield response.json();
            try {
                this.stacks.push(Object.assign(Object.assign({}, data.stack), { applications: data.applications }));
                this.stackPlanGenerated = true;
                return data.stack.name;
            }
            catch (error) {
                console.error(chalk.yellow('Invalid response from create stack'));
                return null;
            }
        });
    }
    /**
     * Initiates the deployment process for the stack modification plan.
     *
     * This function first prints the stack modification plan. If the instance is not in plan mode,
     * it confirms the deployment and starts the deployment process. If in plan mode, it prompts the user
     * for confirmation before proceeding with the deployment.
     *
     * @returns {Promise<void>} - A promise that resolves when the deployment process is complete.
     */
    up() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.stackPlanGenerated) {
                return;
            }
            prettyPrintStackModificationPlan(this.stacks);
            if (!this.isPlan) {
                console.log(chalk.green.bold('Deployment confirmed.'));
                const deployingInterval = loadingSpinner('Deploying...');
                const data = yield this.deployRestackPlan();
                clearInterval(deployingInterval);
                console.log(chalk.green.bold('Deployment plan kicked off successfully. Follow live status at Restack console: ') + chalk.cyan(data.stacksUrl));
                return;
            }
            const deploy = yield this.promptUser('Do you wish to deploy these changes? (y/n): ');
            if (!deploy) {
                console.log(chalk.yellow('Deployment cancelled.'));
                return;
            }
            const deployingInterval = loadingSpinner('Deploying...');
            const data = yield this.deployRestackPlan();
            clearInterval(deployingInterval);
            prettyPrintDeployResults(data.stacks);
            const appWithGithubAppError = getApplicationWithGithubAppError(data.stacks);
            if ((_b = (_a = appWithGithubAppError === null || appWithGithubAppError === void 0 ? void 0 : appWithGithubAppError.details) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.connectUrl) {
                yield open(ensureHttpPrefix(appWithGithubAppError.details[0].connectUrl));
                return;
            }
            if (hasApplicationErrors(data.stacks)) {
                return;
            }
            console.log(chalk.green.bold(`Follow live status at Restack console: ${chalk.cyan(ensureHttpPrefix(data.stacksUrl))}`));
        });
    }
}
export default RestackCloud;
