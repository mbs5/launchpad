"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withMetadata = exports.hasColorSupport = exports.DefaultLogger = exports.timeOfDayToBigint = exports.LogTimestamp = void 0;
const node_util_1 = require("node:util");
const supportsColor = __importStar(require("supports-color"));
const core_bridge_1 = require("@temporalio/core-bridge");
exports.LogTimestamp = Symbol.for('log_timestamp');
const severities = ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR'];
/**
 * @internal
 */
const loggerHasColorsSymbol = Symbol.for('logger_has_colors');
const stderrHasColors = !!supportsColor.stderr;
const format = node_util_1.formatWithOptions.bind(undefined, { colors: stderrHasColors });
/**
 * Log messages to `stderr` using basic formatting
 */
function defaultLogFunction(entry) {
    const { level, timestampNanos, message, meta } = entry;
    const date = new Date(Number(timestampNanos / 1000000n));
    if (meta === undefined) {
        process.stderr.write(`${format(date)} [${level}] ${message}\n`);
    }
    else {
        process.stderr.write(`${format(date)} [${level}] ${message} ${format(meta)}\n`);
    }
}
/**
 * Takes a `[seconds, nanos]` tuple as returned from getTimeOfDay and turns it into bigint.
 */
function timeOfDayToBigint(timeOfDay) {
    const [seconds, nanos] = timeOfDay;
    return BigInt(seconds) * 1000000000n + BigInt(nanos);
}
exports.timeOfDayToBigint = timeOfDayToBigint;
/**
 * Default worker logger - uses a default log function to log messages to `console.error`.
 * See constructor arguments for customization.
 */
class DefaultLogger {
    constructor(level = 'INFO', logFunction = defaultLogFunction) {
        this.level = level;
        this.logFunction = logFunction;
        this.severity = severities.indexOf(this.level);
        this[loggerHasColorsSymbol] =
            (logFunction === defaultLogFunction && stderrHasColors) ?? false;
    }
    log(level, message, meta) {
        if (severities.indexOf(level) >= this.severity) {
            const { [exports.LogTimestamp]: timestampNanos, ...rest } = meta ?? {};
            this.logFunction({
                level,
                message,
                meta: Object.keys(rest).length === 0 ? undefined : rest,
                timestampNanos: timestampNanos ?? timeOfDayToBigint((0, core_bridge_1.getTimeOfDay)()),
            });
        }
    }
    trace(message, meta) {
        this.log('TRACE', message, meta);
    }
    debug(message, meta) {
        this.log('DEBUG', message, meta);
    }
    info(message, meta) {
        this.log('INFO', message, meta);
    }
    warn(message, meta) {
        this.log('WARN', message, meta);
    }
    error(message, meta) {
        this.log('ERROR', message, meta);
    }
}
exports.DefaultLogger = DefaultLogger;
/**
 * @internal
 */
function hasColorSupport(logger) {
    return logger[loggerHasColorsSymbol] ?? false;
}
exports.hasColorSupport = hasColorSupport;
function withMetadata(logger, meta) {
    return new LoggerWithMetadata(logger, meta);
}
exports.withMetadata = withMetadata;
class LoggerWithMetadata {
    constructor(parent, meta) {
        // Flatten recusive LoggerWithMetadata instances
        if (parent instanceof LoggerWithMetadata) {
            this.parentLogger = parent.parentLogger;
            this.metaChain = LoggerWithMetadata.appendToChain(parent.metaChain, meta);
        }
        else {
            this.parentLogger = parent;
            this.metaChain = [meta];
        }
        this[loggerHasColorsSymbol] = hasColorSupport(parent);
    }
    log(level, message, meta) {
        this.parentLogger.log(level, message, this.resolveMetadata(meta));
    }
    trace(message, meta) {
        this.parentLogger.trace(message, this.resolveMetadata(meta));
    }
    debug(message, meta) {
        this.parentLogger.debug(message, this.resolveMetadata(meta));
    }
    info(message, meta) {
        this.parentLogger.info(message, this.resolveMetadata(meta));
    }
    warn(message, meta) {
        this.parentLogger.warn(message, this.resolveMetadata(meta));
    }
    error(message, meta) {
        this.parentLogger.error(message, this.resolveMetadata(meta));
    }
    resolveMetadata(meta) {
        const resolved = {};
        for (const contributor of this.metaChain) {
            Object.assign(resolved, typeof contributor === 'function' ? contributor() : contributor);
        }
        Object.assign(resolved, meta);
        return resolved;
    }
    /**
     * Append a metadata contributor to the chain, merging it with the former last contributor if both are plain objects
     */
    static appendToChain(chain, meta) {
        if (chain.length === 0)
            return [meta];
        const last = chain[chain.length - 1];
        if (typeof last === 'object' && typeof meta === 'object') {
            return [...chain.slice(0, -1), { ...last, ...meta }];
        }
        return [...chain, meta];
    }
}
//# sourceMappingURL=logger.js.map