"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asNativeTuner = void 0;
const time_1 = require("@temporalio/common/lib/time");
function asNativeTuner(tuner) {
    if (isTunerHolder(tuner)) {
        let tunerOptions = undefined;
        const retme = {
            workflowTaskSlotSupplier: fixupResourceBasedOptions(tuner.workflowTaskSlotSupplier, 'workflow'),
            activityTaskSlotSupplier: fixupResourceBasedOptions(tuner.activityTaskSlotSupplier, 'activity'),
            localActivityTaskSlotSupplier: fixupResourceBasedOptions(tuner.localActivityTaskSlotSupplier, 'activity'),
        };
        for (const supplier of [
            retme.workflowTaskSlotSupplier,
            retme.activityTaskSlotSupplier,
            retme.localActivityTaskSlotSupplier,
        ]) {
            if (isResourceBased(supplier)) {
                if (tunerOptions !== undefined) {
                    if (tunerOptions !== supplier.tunerOptions) {
                        throw new TypeError('Cannot construct worker tuner with multiple different tuner options');
                    }
                }
                else {
                    tunerOptions = supplier.tunerOptions;
                }
            }
        }
        return retme;
    }
    else if (isResourceBasedTuner(tuner)) {
        const wftSO = addResourceBasedSlotDefaults(tuner.workflowTaskSlotOptions ?? {}, 'workflow');
        const atSO = addResourceBasedSlotDefaults(tuner.activityTaskSlotOptions ?? {}, 'activity');
        const latSO = addResourceBasedSlotDefaults(tuner.localActivityTaskSlotOptions ?? {}, 'activity');
        return {
            workflowTaskSlotSupplier: {
                type: 'resource-based',
                tunerOptions: tuner.tunerOptions,
                ...wftSO,
                rampThrottleMs: (0, time_1.msToNumber)(wftSO.rampThrottle),
            },
            activityTaskSlotSupplier: {
                type: 'resource-based',
                tunerOptions: tuner.tunerOptions,
                ...atSO,
                rampThrottleMs: (0, time_1.msToNumber)(atSO.rampThrottle),
            },
            localActivityTaskSlotSupplier: {
                type: 'resource-based',
                tunerOptions: tuner.tunerOptions,
                ...latSO,
                rampThrottleMs: (0, time_1.msToNumber)(latSO.rampThrottle),
            },
        };
    }
    else {
        throw new TypeError('Invalid worker tuner configuration');
    }
}
exports.asNativeTuner = asNativeTuner;
const isResourceBasedTuner = (tuner) => Object.hasOwnProperty.call(tuner, 'tunerOptions');
const isTunerHolder = (tuner) => Object.hasOwnProperty.call(tuner, 'workflowTaskSlotSupplier');
const isResourceBased = (sup) => sup.type === 'resource-based';
function fixupResourceBasedOptions(supplier, kind) {
    if (isResourceBased(supplier)) {
        const tunerOptions = supplier.tunerOptions;
        const defaulted = addResourceBasedSlotDefaults(supplier, kind);
        return {
            ...defaulted,
            type: 'resource-based',
            tunerOptions,
            rampThrottleMs: (0, time_1.msToNumber)(defaulted.rampThrottle),
        };
    }
    return supplier;
}
function addResourceBasedSlotDefaults(slotOptions, kind) {
    if (kind === 'workflow') {
        return {
            minimumSlots: slotOptions.minimumSlots ?? 2,
            maximumSlots: slotOptions.maximumSlots ?? 1000,
            rampThrottle: slotOptions.rampThrottle ?? 10,
        };
    }
    else {
        return {
            minimumSlots: slotOptions.minimumSlots ?? 1,
            maximumSlots: slotOptions.maximumSlots ?? 2000,
            rampThrottle: slotOptions.rampThrottle ?? 50,
        };
    }
}
//# sourceMappingURL=worker-tuner.js.map